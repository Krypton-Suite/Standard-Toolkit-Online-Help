<!DOCTYPE html>
<!--[if IE]><![endif]-->
<html>

  <head>
    <meta charset="utf-8">
      <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
      <title>KryptonSystemMenu Complete Features Reference | Krypton Standard Toolkit Documentation </title>
      <meta name="viewport" content="width=device-width">
      <meta name="title" content="KryptonSystemMenu Complete Features Reference | Krypton Standard Toolkit Documentation ">
    
    
      <link rel="shortcut icon" href="../../../../Krypton.ico">
      <link rel="stylesheet" href="../../../../styles/docfx.vendor.min.css">
      <link rel="stylesheet" href="../../../../styles/docfx.css">
      <link rel="stylesheet" href="../../../../styles/main.css">
      <meta property="docfx:navrel" content="../../../../toc.html">
      <meta property="docfx:tocrel" content="../../../toc.html">
    
    
    
  </head>
  <body data-spy="scroll" data-target="#affix" data-offset="120">
    <div id="wrapper">
      <header>

        <nav id="autocollapse" class="navbar navbar-inverse ng-scope" role="navigation">
          <div class="container">
            <div class="navbar-header">
              <button type="button" class="navbar-toggle" data-toggle="collapse" data-target="#navbar">
                <span class="sr-only">Toggle navigation</span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
              </button>

              <a class="navbar-brand" href="../../../../index.html">
                <img id="logo" class="svg" src="../../../../Logo.png" alt="">
              </a>
            </div>
            <div class="collapse navbar-collapse" id="navbar">
              <form class="navbar-form navbar-right" role="search" id="search">
                <div class="form-group">
                  <input type="text" class="form-control" id="search-query" placeholder="Search" autocomplete="off">
                </div>
              </form>
            </div>
          </div>
        </nav>

        <div class="subnav navbar navbar-default">
          <div class="container hide-when-search" id="breadcrumb">
            <ul class="breadcrumb">
              <li></li>
            </ul>
          </div>
        </div>
      </header>
      <div role="main" class="container body-content hide-when-search">

        <div class="sidenav hide-when-search">
          <a class="btn toc-toggle collapse" data-toggle="collapse" href="#sidetoggle" aria-expanded="false" aria-controls="sidetoggle">Show / Hide Table of Contents</a>
          <div class="sidetoggle collapse" id="sidetoggle">
            <div id="sidetoc"></div>
          </div>
        </div>
        <div class="article row grid-right">
          <div class="col-md-10">
            <article class="content wrap" id="_content" data-uid="">
<h1 id="kryptonsystemmenu-complete-features-reference">KryptonSystemMenu Complete Features Reference</h1>

<h2 id="overview">Overview</h2>
<p>The <code>KryptonSystemMenu</code> is a comprehensive themed system menu implementation that provides complete replacement functionality for the native Windows system menu. This document provides detailed information about all features, capabilities, and implementation details.</p>
<h2 id="table-of-contents">Table of Contents</h2>
<ol>
<li><a href="#core-features">Core Features</a></li>
<li><a href="#menu-item-management">Menu Item Management</a></li>
<li><a href="#icon-system">Icon System</a></li>
<li><a href="#theme-integration">Theme Integration</a></li>
<li><a href="#positioning-and-display">Positioning and Display</a></li>
<li><a href="#state-management">State Management</a></li>
<li><a href="#event-handling">Event Handling</a></li>
<li><a href="#performance-features">Performance Features</a></li>
<li><a href="#error-handling">Error Handling</a></li>
<li><a href="#resource-management">Resource Management</a></li>
<li><a href="#advanced-features">Advanced Features</a></li>
</ol>
<h2 id="core-features">Core Features</h2>
<h3 id="1-themed-system-menu-replacement">1. Themed System Menu Replacement</h3>
<ul>
<li><strong>Complete Native Replacement</strong>: Fully replaces the native Windows system menu</li>
<li><strong>KryptonContextMenu Integration</strong>: Built on top of KryptonContextMenu for consistent theming</li>
<li><strong>Seamless Integration</strong>: Works with existing KryptonForm infrastructure</li>
<li><strong>Cross-Platform Compatibility</strong>: Designed for Windows Forms applications</li>
</ul>
<h3 id="2-standard-menu-items-support">2. Standard Menu Items Support</h3>
<p>The system supports all standard Windows system menu items:</p>
<table>
<thead>
<tr>
<th>Menu Item</th>
<th>Description</th>
<th>Icon Support</th>
<th>State Management</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>Restore</strong></td>
<td>Restore window to normal size</td>
<td>✅</td>
<td>Dynamic enable/disable</td>
</tr>
<tr>
<td><strong>Move</strong></td>
<td>Allow window dragging</td>
<td>❌</td>
<td>Based on form border style</td>
</tr>
<tr>
<td><strong>Size</strong></td>
<td>Allow window resizing</td>
<td>❌</td>
<td>Based on form border style</td>
</tr>
<tr>
<td><strong>Minimize</strong></td>
<td>Minimize window to taskbar</td>
<td>✅</td>
<td>Based on MinimizeBox property</td>
</tr>
<tr>
<td><strong>Maximize</strong></td>
<td>Maximize window to full screen</td>
<td>✅</td>
<td>Based on MaximizeBox property</td>
</tr>
<tr>
<td><strong>Close</strong></td>
<td>Close the window</td>
<td>✅</td>
<td>Based on ControlBox property</td>
</tr>
</tbody>
</table>
<h3 id="3-dynamic-menu-structure">3. Dynamic Menu Structure</h3>
<ul>
<li><strong>Conditional Item Display</strong>: Menu items appear/disappear based on form state and properties</li>
<li><strong>Separator Management</strong>: Automatic separator insertion between logical groups</li>
<li><strong>Keyboard Shortcuts</strong>: Support for Alt+F4 (Close) and Alt+Space (Show menu)</li>
<li><strong>Context-Aware</strong>: Menu content adapts to current window state</li>
</ul>
<h2 id="menu-item-management">Menu Item Management</h2>
<h3 id="1-menu-item-creation-and-management">1. Menu Item Creation and Management</h3>
<pre><code class="lang-csharp">// Direct field references for efficient access
private KryptonContextMenuItem? _menuItemRestore;
private KryptonContextMenuItem? _menuItemMove;
private KryptonContextMenuItem? _menuItemSize;
private KryptonContextMenuItem? _menuItemMinimize;
private KryptonContextMenuItem? _menuItemMaximize;
private KryptonContextMenuItem? _menuItemClose;
</code></pre>
<h3 id="2-conditional-menu-item-logic">2. Conditional Menu Item Logic</h3>
<p>The system implements sophisticated logic for when to show each menu item:</p>
<h4 id="restore-item">Restore Item</h4>
<pre><code class="lang-csharp">// Only show if window is not in normal state and either minimize or maximize is enabled
if (_form.WindowState != FormWindowState.Normal &amp;&amp; (_form.MinimizeBox || _form.MaximizeBox))
{
    // Add restore item
}
</code></pre>
<h4 id="move-and-size-items">Move and Size Items</h4>
<pre><code class="lang-csharp">// Only add if the window is resizable
if (_form.FormBorderStyle != FormBorderStyle.FixedSingle &amp;&amp; 
    _form.FormBorderStyle != FormBorderStyle.Fixed3D &amp;&amp; 
    _form.FormBorderStyle != FormBorderStyle.FixedDialog)
{
    // Add move and size items
}
</code></pre>
<h4 id="separator-logic">Separator Logic</h4>
<pre><code class="lang-csharp">// Add separator if we have items before it and either minimize or maximize is enabled
if (_contextMenu.Items.Count &gt; 0 &amp;&amp; (_form.MinimizeBox || _form.MaximizeBox))
{
    _contextMenu.Items.Add(new KryptonContextMenuSeparator());
}
</code></pre>
<h3 id="3-menu-item-state-management">3. Menu Item State Management</h3>
<p>Dynamic enable/disable based on current form state:</p>
<pre><code class="lang-csharp">private void UpdateMenuItemsState()
{
    var windowState = _form.GetWindowState();

    // Restore: enabled when window is not in normal state
    if (_menuItemRestore != null) 
    {
        _menuItemRestore.Enabled = (windowState != FormWindowState.Normal);
    }
    
    // Minimize: enabled only if MinimizeBox is true and not already minimized
    if (_menuItemMinimize != null) 
    {
        _menuItemMinimize.Enabled = _form.MinimizeBox &amp;&amp; (windowState != FormWindowState.Minimized);
    }

    // Maximize: enabled only if MaximizeBox is true and not already maximized
    if (_menuItemMaximize != null)
    {
        _menuItemMaximize.Enabled = _form.MaximizeBox &amp;&amp; (windowState != FormWindowState.Maximized);
    }
    
    // Move: enabled when window is in Normal state or minimized
    if (_menuItemMove != null)
    {
        _menuItemMove.Enabled = (windowState == FormWindowState.Normal) || (windowState == FormWindowState.Minimized);
    }
    
    // Size: enabled when window is in Normal state and form is sizable
    if (_menuItemSize != null)
    {
        _menuItemSize.Enabled = (windowState == FormWindowState.Normal) &amp;&amp;
                               (_form.FormBorderStyle == FormBorderStyle.Sizable || 
                                _form.FormBorderStyle == FormBorderStyle.SizableToolWindow);
    }
}
</code></pre>
<h2 id="icon-system">Icon System</h2>
<h3 id="1-multi-theme-icon-support">1. Multi-Theme Icon Support</h3>
<p>The system supports 7 different icon themes:</p>
<table>
<thead>
<tr>
<th>Theme</th>
<th>Description</th>
<th>Icon Style</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>Office2013</strong></td>
<td>Modern, clean icons</td>
<td>Flat, minimal design</td>
</tr>
<tr>
<td><strong>Office2010</strong></td>
<td>Classic Office 2010</td>
<td>Traditional Windows style</td>
</tr>
<tr>
<td><strong>Office2007</strong></td>
<td>Office 2007 style</td>
<td>Ribbon-era design</td>
</tr>
<tr>
<td><strong>Sparkle</strong></td>
<td>Vibrant, colorful</td>
<td>Bright, eye-catching</td>
</tr>
<tr>
<td><strong>Professional</strong></td>
<td>Neutral, professional</td>
<td>Business-appropriate</td>
</tr>
<tr>
<td><strong>Microsoft365</strong></td>
<td>Modern Microsoft 365</td>
<td>Contemporary design</td>
</tr>
<tr>
<td><strong>Office2003</strong></td>
<td>Classic Office 2003</td>
<td>Legacy Windows style</td>
</tr>
</tbody>
</table>
<h3 id="2-automatic-theme-detection">2. Automatic Theme Detection</h3>
<pre><code class="lang-csharp">public string GetCurrentTheme()
{
    var palette = _form.GetResolvedPalette();
    var headerColor = palette.GetBackColor1(PaletteBackStyle.HeaderForm, PaletteState.Normal);

    return headerColor switch
    {
        var color when IsLightColor(color) =&gt; &quot;Office2013&quot;,
        var color when IsBlueTone(color) =&gt; &quot;Office2010&quot;,
        var color when IsDarkBlueTone(color) =&gt; &quot;Office2007&quot;,
        var color when IsVibrantColor(color) =&gt; &quot;Sparkle&quot;,
        var color when IsNeutralTone(color) =&gt; &quot;Professional&quot;,
        var color when IsModernColor(color) =&gt; &quot;Microsoft365&quot;,
        var color when IsClassicColor(color) =&gt; &quot;Office2003&quot;,
        _ =&gt; &quot;Office2013&quot; // default fallback
    };
}
</code></pre>
<h3 id="3-color-based-theme-detection">3. Color-Based Theme Detection</h3>
<p>The system uses sophisticated color analysis to determine the appropriate theme:</p>
<h4 id="light-color-detection">Light Color Detection</h4>
<pre><code class="lang-csharp">private bool IsLightColor(Color color)
{
    var brightness = (0.299 * color.R + 0.587 * color.G + 0.114 * color.B) / 255;
    return brightness &gt; 0.6;
}
</code></pre>
<h4 id="blue-tone-detection">Blue Tone Detection</h4>
<pre><code class="lang-csharp">private bool IsBlueTone(Color color)
{
    return color.B &gt; color.R &amp;&amp; color.B &gt; color.G &amp;&amp; color.B &gt; 100;
}
</code></pre>
<h4 id="dark-blue-tone-detection">Dark Blue Tone Detection</h4>
<pre><code class="lang-csharp">private bool IsDarkBlueTone(Color color)
{
    return color.B &gt; color.R &amp;&amp; color.B &gt; color.G &amp;&amp; color.B &lt; 100;
}
</code></pre>
<h3 id="4-fallback-icon-generation">4. Fallback Icon Generation</h3>
<p>When theme-specific icons are unavailable, the system generates custom drawn icons:</p>
<pre><code class="lang-csharp">private Image? GetDrawnIcon(SystemMenuIconType iconType)
{
    const int iconSize = 16;
    var bitmap = new Bitmap(iconSize, iconSize);

    using (var graphics = Graphics.FromImage(bitmap))
    {
        graphics.SmoothingMode = SmoothingMode.AntiAlias;
        graphics.Clear(Color.Transparent);

        var foregroundColor = GetThemeForegroundColor();
        var backgroundColor = GetThemeBackgroundColor();

        switch (iconType)
        {
            case SystemMenuIconType.Restore:
                DrawRestoreIcon(graphics, iconSize, foregroundColor, backgroundColor);
                break;
            case SystemMenuIconType.Minimize:
                DrawMinimizeIcon(graphics, iconSize, foregroundColor);
                break;
            case SystemMenuIconType.Maximize:
                DrawMaximizeIcon(graphics, iconSize, foregroundColor);
                break;
            case SystemMenuIconType.Close:
                DrawCloseIcon(graphics, iconSize, foregroundColor);
                break;
        }
    }

    return bitmap;
}
</code></pre>
<h3 id="5-custom-icon-drawing">5. Custom Icon Drawing</h3>
<p>The system includes custom drawing methods for each icon type:</p>
<h4 id="restore-icon">Restore Icon</h4>
<pre><code class="lang-csharp">private void DrawRestoreIcon(Graphics graphics, int size, Color foregroundColor, Color backgroundColor)
{
    var pen = new Pen(foregroundColor, 1);
    var brush = new SolidBrush(backgroundColor);

    // Draw the main square
    var rect = new Rectangle(2, 2, size - 4, size - 4);
    graphics.FillRectangle(brush, rect);
    graphics.DrawRectangle(pen, rect);

    // Draw the arrow pointing to the square
    var arrowPoints = new Point[]
    {
        new Point(size - 6, 4),
        new Point(size - 6, size - 6),
        new Point(4, size - 6)
    };
    graphics.FillPolygon(brush, arrowPoints);
    graphics.DrawPolygon(pen, arrowPoints);

    pen.Dispose();
    brush.Dispose();
}
</code></pre>
<h4 id="minimize-icon">Minimize Icon</h4>
<pre><code class="lang-csharp">private void DrawMinimizeIcon(Graphics graphics, int size, Color foregroundColor)
{
    var pen = new Pen(foregroundColor, 2);
    var y = size / 2;
    graphics.DrawLine(pen, 3, y, size - 3, y);
    pen.Dispose();
}
</code></pre>
<h4 id="maximize-icon">Maximize Icon</h4>
<pre><code class="lang-csharp">private void DrawMaximizeIcon(Graphics graphics, int size, Color foregroundColor)
{
    var pen = new Pen(foregroundColor, 1);
    var rect = new Rectangle(2, 2, size - 4, size - 4);
    graphics.DrawRectangle(pen, rect);
    pen.Dispose();
}
</code></pre>
<h4 id="close-icon">Close Icon</h4>
<pre><code class="lang-csharp">private void DrawCloseIcon(Graphics graphics, int size, Color foregroundColor)
{
    var pen = new Pen(foregroundColor, 2);
    graphics.DrawLine(pen, 3, 3, size - 3, size - 3);
    graphics.DrawLine(pen, 3, size - 3, size - 3, 3);
    pen.Dispose();
}
</code></pre>
<h2 id="theme-integration">Theme Integration</h2>
<h3 id="1-palette-integration">1. Palette Integration</h3>
<p>The system integrates deeply with the Krypton palette system:</p>
<pre><code class="lang-csharp">private Color GetThemeForegroundColor()
{
    var palette = _form.GetResolvedPalette();
    if (palette != null)
    {
        return palette.GetContentShortTextColor1(PaletteContentStyle.HeaderForm, PaletteState.Normal);
    }
    return Color.Black; // fallback
}

private Color GetThemeBackgroundColor()
{
    var palette = _form.GetResolvedPalette();
    if (palette != null)
    {
        return palette.GetBackColor1(PaletteBackStyle.HeaderForm, PaletteState.Normal);
    }
    return Color.White; // fallback
}
</code></pre>
<h3 id="2-theme-change-handling">2. Theme Change Handling</h3>
<pre><code class="lang-csharp">public void RefreshThemeIcons()
{
    RefreshIcons();
}

public void SetIconTheme(string themeName)
{
    if (string.IsNullOrEmpty(themeName))
    {
        return;
    }
    RefreshIcons();
}

public void SetThemeType(ThemeType themeType)
{
    string themeName = themeType switch
    {
        ThemeType.Black =&gt; &quot;Office2013&quot;,
        ThemeType.Blue =&gt; &quot;Office2010&quot;,
        ThemeType.Silver =&gt; &quot;Office2013&quot;,
        ThemeType.DarkBlue =&gt; &quot;Office2010&quot;,
        ThemeType.LightBlue =&gt; &quot;Office2010&quot;,
        ThemeType.WarmSilver =&gt; &quot;Office2013&quot;,
        ThemeType.ClassicSilver =&gt; &quot;Office2007&quot;,
        _ =&gt; &quot;Office2013&quot;
    };
    SetIconTheme(themeName);
}
</code></pre>
<h2 id="positioning-and-display">Positioning and Display</h2>
<h3 id="1-smart-positioning">1. Smart Positioning</h3>
<p>The system includes intelligent positioning logic to ensure menus stay within screen bounds:</p>
<pre><code class="lang-csharp">private Point AdjustMenuPosition(Point originalLocation)
{
    var screenBounds = Screen.FromControl(_form).Bounds;
    var estimatedMenuWidth = 200;
    var estimatedMenuHeight = _contextMenu.Items.Count * 25;

    // Check if menu would go off the right edge
    if (originalLocation.X + estimatedMenuWidth &gt; screenBounds.Right)
    {
        originalLocation.X = screenBounds.Right - estimatedMenuWidth;
    }

    // Check if menu would go off the bottom edge
    if (originalLocation.Y + estimatedMenuHeight &gt; screenBounds.Bottom)
    {
        originalLocation.Y = screenBounds.Bottom - estimatedMenuHeight;
    }

    // Ensure menu doesn't go off the left or top edges
    if (originalLocation.X &lt; screenBounds.Left)
    {
        originalLocation.X = screenBounds.Left;
    }

    if (originalLocation.Y &lt; screenBounds.Top)
    {
        originalLocation.Y = screenBounds.Top;
    }

    return originalLocation;
}
</code></pre>
<h3 id="2-multiple-display-methods">2. Multiple Display Methods</h3>
<ul>
<li><strong>Show(Point)</strong>: Show at specific screen coordinates</li>
<li><strong>ShowAtFormTopLeft()</strong>: Show at form's top-left corner (native behavior)</li>
<li><strong>Automatic positioning</strong>: Adjusts position to stay within screen bounds</li>
</ul>
<h3 id="3-screen-awareness">3. Screen Awareness</h3>
<pre><code class="lang-csharp">public void Show(Point screenLocation)
{
    if (Enabled &amp;&amp; _contextMenu.Items.Count &gt; 0)
    {
        var adjustedLocation = AdjustMenuPosition(screenLocation);
        _contextMenu.Show(_form, adjustedLocation);
    }
}
</code></pre>
<h2 id="state-management">State Management</h2>
<h3 id="1-form-state-integration">1. Form State Integration</h3>
<p>The system monitors and responds to form state changes:</p>
<pre><code class="lang-csharp">public void Refresh()
{
    ThrowIfDisposed();
    BuildSystemMenu();
    UpdateMenuItemsState();
    RefreshIcons();
}
</code></pre>
<h3 id="2-property-based-state-management">2. Property-Based State Management</h3>
<p>Menu items are enabled/disabled based on form properties:</p>
<table>
<thead>
<tr>
<th>Form Property</th>
<th>Affects</th>
<th>Logic</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>MinimizeBox</code></td>
<td>Minimize item</td>
<td>Must be true to enable minimize</td>
</tr>
<tr>
<td><code>MaximizeBox</code></td>
<td>Maximize item</td>
<td>Must be true to enable maximize</td>
</tr>
<tr>
<td><code>ControlBox</code></td>
<td>Close item</td>
<td>Must be true to show close</td>
</tr>
<tr>
<td><code>FormBorderStyle</code></td>
<td>Move/Size items</td>
<td>Must be resizable to show move/size</td>
</tr>
<tr>
<td><code>WindowState</code></td>
<td>All items</td>
<td>Current state affects availability</td>
</tr>
</tbody>
</table>
<h3 id="3-dynamic-state-updates">3. Dynamic State Updates</h3>
<pre><code class="lang-csharp">private void UpdateMenuItemsState()
{
    var windowState = _form.GetWindowState();

    // Update each menu item based on current state
    if (_menuItemRestore != null) 
    {
        _menuItemRestore.Enabled = (windowState != FormWindowState.Normal);
    }
    // ... other items
}
</code></pre>
<h2 id="event-handling">Event Handling</h2>
<h3 id="1-menu-item-click-events">1. Menu Item Click Events</h3>
<p>Each menu item has dedicated event handlers:</p>
<pre><code class="lang-csharp">private void OnRestoreItemOnClick(object? sender, EventArgs e) =&gt; ExecuteRestore();
private void OnMinimizeItemOnClick(object? sender, EventArgs e) =&gt; ExecuteMinimize();
private void OnMaximizeItemOnClick(object? sender, EventArgs e) =&gt; ExecuteMaximize();
private void OnCloseItemOnClick(object? sender, EventArgs e) =&gt; ExecuteClose();
</code></pre>
<h3 id="2-action-execution">2. Action Execution</h3>
<p>Each action is implemented with proper fallback mechanisms:</p>
<h4 id="restore-action">Restore Action</h4>
<pre><code class="lang-csharp">private void ExecuteRestore()
{
    try
    {
        if (_form.WindowState != FormWindowState.Normal)
        {
            _form.WindowState = FormWindowState.Normal;
        }
        else
        {
            SendSysCommand(PI.SC_.RESTORE);
        }
    }
    catch
    {
        SendSysCommand(PI.SC_.RESTORE);
    }
}
</code></pre>
<h4 id="move-action">Move Action</h4>
<pre><code class="lang-csharp">private void ExecuteMove()
{
    try
    {
        SendSysCommand(PI.SC_.MOVE);
    }
    catch
    {
        SendSysCommand(PI.SC_.MOVE);
    }
}
</code></pre>
<h4 id="size-action">Size Action</h4>
<pre><code class="lang-csharp">private void ExecuteSize()
{
    try
    {
        SendSysCommand(PI.SC_.SIZE);
    }
    catch
    {
        SendSysCommand(PI.SC_.SIZE);
    }
}
</code></pre>
<h3 id="3-system-command-integration">3. System Command Integration</h3>
<pre><code class="lang-csharp">private void SendSysCommand(PI.SC_ command)
{
    var screenPos = Control.MousePosition;
    var lParam = (IntPtr)(PI.MAKELOWORD(screenPos.X) | PI.MAKEHIWORD(screenPos.Y));
    _form.SendSysCommand(command, lParam);
}
</code></pre>
<h2 id="performance-features">Performance Features</h2>
<h3 id="1-efficient-resource-management">1. Efficient Resource Management</h3>
<ul>
<li><strong>Direct Field References</strong>: Uses direct field references for menu items instead of searching collections</li>
<li><strong>Icon Caching</strong>: Icons are cached and only regenerated when themes change</li>
<li><strong>Lazy Loading</strong>: Menu items are created only when needed</li>
<li><strong>Memory Management</strong>: Proper disposal of graphics resources</li>
</ul>
<h3 id="2-optimized-state-updates">2. Optimized State Updates</h3>
<pre><code class="lang-csharp">private void UpdateMenuItemsState()
{
    // Direct field access for performance
    if (_menuItemRestore != null) 
    {
        _menuItemRestore.Enabled = (windowState != FormWindowState.Normal);
    }
    // ... efficient updates
}
</code></pre>
<h3 id="3-smart-refresh-logic">3. Smart Refresh Logic</h3>
<pre><code class="lang-csharp">public void Refresh()
{
    ThrowIfDisposed();
    BuildSystemMenu();        // Rebuild structure
    UpdateMenuItemsState();   // Update states
    RefreshIcons();          // Update icons
}
</code></pre>
<h2 id="error-handling">Error Handling</h2>
<h3 id="1-comprehensive-exception-handling">1. Comprehensive Exception Handling</h3>
<pre><code class="lang-csharp">private void BuildSystemMenu()
{
    try
    {
        _contextMenu.Items.Clear();
        CreateBasicMenuItems();
    }
    catch (Exception ex)
    {
        Debug.WriteLine($&quot;Error building system menu: {ex.Message}&quot;);
        
        if (_contextMenu.Items.Count == 0)
        {
            CreateBasicMenuItems();
        }
    }
}
</code></pre>
<h3 id="2-graceful-degradation">2. Graceful Degradation</h3>
<pre><code class="lang-csharp">private Image? GetSystemMenuIcon(SystemMenuIconType iconType)
{
    try
    {
        var currentTheme = GetCurrentTheme();
        var icon = GetThemeIcon(currentTheme, iconType);
        if (icon != null)
        {
            var processedIcon = ProcessImageForTransparency(icon);
            if (processedIcon != null)
            {
                return processedIcon;
            }
        }
        return GetDrawnIcon(iconType);
    }
    catch
    {
        return null; // Graceful fallback
    }
}
</code></pre>
<h3 id="3-disposal-safety">3. Disposal Safety</h3>
<pre><code class="lang-csharp">public void Show(Point screenLocation)
{
    ThrowIfDisposed();
    if (Enabled &amp;&amp; _contextMenu.Items.Count &gt; 0)
    {
        var adjustedLocation = AdjustMenuPosition(screenLocation);
        _contextMenu.Show(_form, adjustedLocation);
    }
}

private void ThrowIfDisposed()
{
    if (_disposed)
    {
        throw new ObjectDisposedException(nameof(KryptonSystemMenu));
    }
}
</code></pre>
<h2 id="resource-management">Resource Management</h2>
<h3 id="1-idisposable-implementation">1. IDisposable Implementation</h3>
<pre><code class="lang-csharp">public void Dispose()
{
    Dispose(true);
    GC.SuppressFinalize(this);
}

protected virtual void Dispose(bool disposing)
{
    if (!_disposed)
    {
        if (disposing)
        {
            _contextMenu.Dispose();
        }
        _disposed = true;
    }
}

~KryptonSystemMenu()
{
    Dispose(false);
}
</code></pre>
<h3 id="2-graphics-resource-management">2. Graphics Resource Management</h3>
<pre><code class="lang-csharp">private void DrawRestoreIcon(Graphics graphics, int size, Color foregroundColor, Color backgroundColor)
{
    var pen = new Pen(foregroundColor, 1);
    var brush = new SolidBrush(backgroundColor);

    try
    {
        // Drawing operations
        var rect = new Rectangle(2, 2, size - 4, size - 4);
        graphics.FillRectangle(brush, rect);
        graphics.DrawRectangle(pen, rect);
        // ... more drawing
    }
    finally
    {
        pen.Dispose();
        brush.Dispose();
    }
}
</code></pre>
<h3 id="3-image-processing">3. Image Processing</h3>
<pre><code class="lang-csharp">private Image? ProcessImageForTransparency(Image? originalImage)
{
    if (originalImage == null)
    {
        return null;
    }

    try
    {
        if (originalImage.PixelFormat == PixelFormat.Format32bppArgb)
        {
            return originalImage; // Already in correct format
        }

        var bitmap = new Bitmap(originalImage.Width, originalImage.Height, PixelFormat.Format32bppArgb);
        using (var graphics = Graphics.FromImage(bitmap))
        {
            graphics.Clear(Color.Transparent);
            graphics.DrawImage(originalImage, 0, 0);
        }
        return bitmap;
    }
    catch (Exception ex)
    {
        Debug.WriteLine($&quot;Failed to process image transparency: {ex.Message}&quot;);
        return originalImage;
    }
}
</code></pre>
<h2 id="advanced-features">Advanced Features</h2>
<h3 id="1-keyboard-shortcut-handling">1. Keyboard Shortcut Handling</h3>
<pre><code class="lang-csharp">public bool HandleKeyboardShortcut(Keys keyData)
{
    ThrowIfDisposed();
    if (!Enabled)
    {
        return false;
    }

    // Handle Alt+F4 for Close
    if (keyData == (Keys.Alt | Keys.F4))
    {
        ExecuteClose();
        return true;
    }

    // Handle Alt+Space for showing the menu
    if (keyData == (Keys.Alt | Keys.Space) &amp;&amp; ShowOnAltSpace)
    {
        ShowAtFormTopLeft();
        return true;
    }

    return false;
}
</code></pre>
<h3 id="2-icon-type-detection">2. Icon Type Detection</h3>
<pre><code class="lang-csharp">private SystemMenuIconType? GetIconTypeFromText(string text)
{
    if (string.IsNullOrEmpty(text))
    {
        return null;
    }

    var normalizedText = text.ToLowerInvariant().Trim();

    if (normalizedText.StartsWith(KryptonManager.Strings.SystemMenuStrings.Restore.ToLower()))
    {
        return SystemMenuIconType.Restore;
    }
    // ... other types
    return null;
}
</code></pre>
<h3 id="3-theme-resource-management">3. Theme Resource Management</h3>
<pre><code class="lang-csharp">private Image? GetOffice2013Icon(SystemMenuIconType iconType)
{
    try
    {
        switch (iconType)
        {
            case SystemMenuIconType.Restore:
                return SystemMenuImageResources.Microsoft365SystemMenuRestoreNormalSmall;
            case SystemMenuIconType.Minimize:
                return SystemMenuImageResources.Microsoft365SystemMenuMinimiseNormalSmall;
            case SystemMenuIconType.Maximize:
                return SystemMenuImageResources.Microsoft365SystemMenuMaximiseNormalSmall;
            case SystemMenuIconType.Close:
                return SystemMenuImageResources.Microsoft365SystemMenuCloseNormalSmall;
            default:
                return null;
        }
    }
    catch
    {
        return null;
    }
}
</code></pre>
<h3 id="4-multi-screen-support">4. Multi-Screen Support</h3>
<p>The positioning system is aware of multiple screens and adjusts menu position accordingly:</p>
<pre><code class="lang-csharp">private Point AdjustMenuPosition(Point originalLocation)
{
    var screenBounds = Screen.FromControl(_form).Bounds;
    // ... positioning logic that respects screen boundaries
}
</code></pre>
<h2 id="configuration-options">Configuration Options</h2>
<h3 id="1-behavior-configuration">1. Behavior Configuration</h3>
<ul>
<li><code>Enabled</code>: Enable/disable the entire system menu</li>
<li><code>ShowOnLeftClick</code>: Control left-click behavior</li>
<li><code>ShowOnRightClick</code>: Control right-click behavior</li>
<li><code>ShowOnAltSpace</code>: Control Alt+Space behavior</li>
</ul>
<h3 id="2-theme-configuration">2. Theme Configuration</h3>
<ul>
<li><code>CurrentIconTheme</code>: Get current theme name</li>
<li><code>SetIconTheme(string)</code>: Set specific theme</li>
<li><code>SetThemeType(ThemeType)</code>: Set theme by type</li>
<li><code>RefreshThemeIcons()</code>: Force icon refresh</li>
</ul>
<h3 id="3-state-configuration">3. State Configuration</h3>
<ul>
<li><code>MenuItemCount</code>: Get number of menu items</li>
<li><code>HasMenuItems</code>: Check if menu has items</li>
<li><code>Refresh()</code>: Force complete refresh</li>
</ul>
<h2 id="integration-points">Integration Points</h2>
<h3 id="1-kryptonform-integration">1. KryptonForm Integration</h3>
<ul>
<li>Direct integration through form properties</li>
<li>Automatic state synchronization</li>
<li>Theme inheritance from form palette</li>
</ul>
<h3 id="2-kryptoncontextmenu-integration">2. KryptonContextMenu Integration</h3>
<ul>
<li>Built on top of KryptonContextMenu</li>
<li>Inherits all context menu features</li>
<li>Consistent theming and behavior</li>
</ul>
<h3 id="3-palette-system-integration">3. Palette System Integration</h3>
<ul>
<li>Automatic theme detection</li>
<li>Color-based theme selection</li>
<li>Dynamic icon adaptation</li>
</ul>
<p>This comprehensive feature reference covers all aspects of the KryptonSystemMenu implementation, from basic functionality to advanced features and performance optimizations.</p>

</article>
          </div>

          <div class="hidden-sm col-md-2" role="complementary">
            <div class="sideaffix">
              <nav class="bs-docs-sidebar hidden-print hidden-xs hidden-sm affix" id="affix">
              </nav>
            </div>
          </div>
        </div>
      </div>

      <footer>
        <div class="grad-bottom"></div>
        <div class="footer">
          <div class="container">
            <span class="pull-right">
              <a href="#top">Back to top</a>
            </span>
      <span>Krypton Component Suite 2024
BSD 3-Clause License
© Component Factory Pty Ltd, 2006 - 2016, All rights reserved.</span> <span>Modifications by Peter Wagner (aka Wagnerp), Simon Coghlan (aka Smurf-IV), Giduac, Tobitege, Lesarndro, KamaniAR & Ahmed Abdelhameed et al. 2017 - 2025. All rights reserved. <a href="https://github.com/Krypton-Suite">https://github.com/Krypton-Suite</a></span>
      
          </div>
        </div>
      </footer>
    </div>

    <script type="text/javascript" src="../../../../styles/docfx.vendor.min.js"></script>
    <script type="text/javascript" src="../../../../styles/docfx.js"></script>
    <script type="text/javascript" src="../../../../styles/main.js"></script>
  </body>
</html>
